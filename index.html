<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIアンビエント臨床記録デモ (不具合修正版 v2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .loader {
            border-top-color: #3498db;
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .glowing-indicator {
            animation: glowing 2s infinite;
        }
        @keyframes glowing {
            0% { box-shadow: 0 0 3px #ef4444; }
            50% { box-shadow: 0 0 15px #ef4444; }
            100% { box-shadow: 0 0 3px #ef4444; }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <!-- Header -->
        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">AIアンビエント臨床記録デモ</h1>
            <p class="mt-2 text-gray-600">医師と患者の会話から、AIが自動でカルテや文書を作成します。</p>
        </header>

        <!-- Main Content -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">

            <!-- Left Column: Input & Transcription -->
            <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-gray-800">診察コントロール</h2>
                    <div id="status-indicator" class="flex items-center space-x-2">
                        <span class="relative flex h-3 w-3">
                            <span id="status-dot" class="absolute inline-flex h-full w-full rounded-full bg-gray-400 opacity-75"></span>
                            <span class="relative inline-flex rounded-full h-3 w-3 bg-gray-400"></span>
                        </span>
                        <span id="status-text" class="text-gray-600 font-medium">待機中</span>
                    </div>
                </div>

                <div class="text-center bg-blue-100 text-blue-800 p-2 rounded-lg mb-4">
                    AI処理の試用回数: <span id="trial-count-display" class="font-bold">3</span> / 3 回
                </div>

                <div class="flex flex-col sm:flex-row gap-4 mb-6">
                    <button id="startButton" class="w-full flex items-center justify-center gap-2 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-all shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
                        診察開始
                    </button>
                    <button id="stopButton" class="w-full flex items-center justify-center gap-2 bg-red-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-red-700 transition-all shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10,0,1,0,22,12,10,10,0,0,0,12,2Zm0,18a8,8,0,1,1,8-8A8,8,0,0,1,12,20ZM10,8h4v8H10Z"/></svg>
                        診察終了 & AI処理
                    </button>
                </div>

                <div class="mt-4 space-y-4">
                    <div>
                        <h3 class="font-bold text-lg mb-2 text-gray-700">1. 会話のリアルタイム文字起こし</h3>
                        <div id="transcript" class="w-full h-40 p-4 bg-gray-100 rounded-lg border border-gray-300 overflow-y-auto text-gray-700">
                            <p class="text-gray-400">ここに会話内容がリアルタイムで表示されます。</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="font-bold text-lg mb-2 text-gray-700">2. AIによる自動修正・清書</h3>
                        <div id="proofread-transcript" class="w-full h-40 p-4 bg-green-50 rounded-lg border border-green-300 overflow-y-auto text-gray-800">
                            <p class="text-gray-400">AI処理後に、誤字脱字などを修正したテキストがここに表示されます。</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: AI Output -->
            <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200 relative">
                <div id="loading-overlay" class="absolute inset-0 bg-white bg-opacity-80 flex-col items-center justify-center rounded-2xl z-10 hidden">
                    <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-24 w-24"></div>
                    <p id="loading-text" class="mt-4 text-lg font-semibold text-gray-700">Gemini AIが処理中...</p>
                </div>

                <h2 class="text-xl font-bold text-gray-800 mb-4">3. AIによる生成結果</h2>
                
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex space-x-6" aria-label="Tabs">
                        <button id="tab-soap" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-blue-600 border-blue-600">
                            SOAP形式カルテ
                        </button>
                        <button id="tab-referral" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm text-gray-500 hover:text-gray-700 hover:border-gray-300 border-transparent">
                            紹介状
                        </button>
                    </nav>
                </div>

                <div id="content-soap" class="mt-6 space-y-4">
                    <div>
                        <h4 class="font-semibold text-gray-700">S: Subjective (主観的情報)</h4>
                        <div id="output-s" class="mt-1 p-3 bg-gray-100 rounded-md min-h-[50px] text-gray-600 border border-gray-200"></div>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-700">O: Objective (客観的情報)</h4>
                        <div id="output-o" class="mt-1 p-3 bg-gray-100 rounded-md min-h-[50px] text-gray-600 border border-gray-200"></div>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-700">A: Assessment (評価)</h4>
                        <div id="output-a" class="mt-1 p-3 bg-gray-100 rounded-md min-h-[50px] text-gray-600 border border-gray-200"></div>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-700">P: Plan (計画)</h4>
                        <div id="output-p" class="mt-1 p-3 bg-gray-100 rounded-md min-h-[50px] text-gray-600 border border-gray-200"></div>
                    </div>
                </div>

                <div id="content-referral" class="mt-6 hidden">
                     <h4 class="font-semibold text-gray-700">紹介状 (下書き)</h4>
                     <div id="output-referral-letter" class="mt-1 p-3 bg-gray-100 rounded-md min-h-[200px] text-gray-600 border border-gray-200 whitespace-pre-wrap"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const transcriptDiv = document.getElementById('transcript');
        const proofreadTranscriptDiv = document.getElementById('proofread-transcript');
        const statusIndicator = document.getElementById('status-indicator');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const trialCountDisplay = document.getElementById('trial-count-display');
        
        const outputS = document.getElementById('output-s');
        const outputO = document.getElementById('output-o');
        const outputA = document.getElementById('output-a');
        const outputP = document.getElementById('output-p');
        const outputReferralLetter = document.getElementById('output-referral-letter');

        const tabSoap = document.getElementById('tab-soap');
        const tabReferral = document.getElementById('tab-referral');
        const contentSoap = document.getElementById('content-soap');
        const contentReferral = document.getElementById('content-referral');

        const MAX_TRIALS = 3;
        let trialCount = 0;

        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.lang = 'ja-JP';
            recognition.interimResults = true;
        } else {
            transcriptDiv.innerHTML = '<p class="text-red-500">お使いのブラウザは音声認識に対応していません。</p>';
            startButton.disabled = true;
            stopButton.disabled = true;
        }

        let finalTranscript = '';
        let isRecording = false;
        let userStopped = false; 

        function updateTrialDisplay() {
            const remaining = Math.max(0, MAX_TRIALS - trialCount);
            trialCountDisplay.textContent = `${remaining} / ${MAX_TRIALS}`;
        }

        function checkTrialLimitAndDisable() {
            if (trialCount >= MAX_TRIALS) {
                startButton.disabled = true;
                stopButton.disabled = true;
                const icon = startButton.querySelector('svg');
                startButton.innerHTML = '試用回数を超えました';
                if(icon) startButton.prepend(icon);
                startButton.classList.add('bg-gray-400', 'cursor-not-allowed');
                startButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const savedCount = localStorage.getItem('aiScribeTrialCount');
            trialCount = savedCount ? parseInt(savedCount, 10) : 0;
            updateTrialDisplay();
            checkTrialLimitAndDisable();
        });

        startButton.addEventListener('click', () => {
            if (trialCount >= MAX_TRIALS) {
                alert('試用回数を超えました。ご利用ありがとうございました。');
                return;
            }
            if (!isRecording && recognition) {
                finalTranscript = '';
                transcriptDiv.innerHTML = '<p class="text-gray-400">マイクに話しかけてください...</p>';
                proofreadTranscriptDiv.innerHTML = '<p class="text-gray-400">AI処理後に、修正されたテキストが表示されます。</p>';
                userStopped = false; 
                try {
                    recognition.start();
                } catch(e) {
                    console.error("Recognition start failed:", e);
                    alert("音声認識の開始に失敗しました。マイクが接続されているか、ブラウザのマイク使用が許可されているか確認してください。");
                }
            }
        });

        stopButton.addEventListener('click', () => {
            if (isRecording && recognition) {
                userStopped = true; 
                recognition.stop();
                // AI processing is now triggered from the 'onend' event when userStopped is true
            }
        });

        tabSoap.addEventListener('click', () => {
            contentSoap.classList.remove('hidden');
            contentReferral.classList.add('hidden');
            tabSoap.classList.add('text-blue-600', 'border-blue-600');
            tabSoap.classList.remove('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent');
            tabReferral.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent');
            tabReferral.classList.remove('text-blue-600', 'border-blue-600');
        });

        tabReferral.addEventListener('click', () => {
            contentReferral.classList.remove('hidden');
            contentSoap.classList.add('hidden');
            tabReferral.classList.add('text-blue-600', 'border-blue-600');
            tabReferral.classList.remove('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent');
            tabSoap.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300', 'border-transparent');
            tabSoap.classList.remove('text-blue-600', 'border-blue-600');
        });

        if (recognition) {
            recognition.onstart = () => {
                isRecording = true;
                startButton.disabled = true;
                stopButton.disabled = false;
                updateStatus('recording');
            };

            recognition.onend = () => {
                isRecording = false;
                if (userStopped) {
                    // This is an intentional stop by the user.
                    startButton.disabled = false;
                    stopButton.disabled = true;
                    updateStatus('processing', 'AIが会話を清書中...');
                    processWithAI(finalTranscript);
                } else {
                    // This was an automatic stop (e.g., silence). Restart it.
                    if (!userStopped) {
                        try {
                            recognition.start();
                        } catch (e) {
                            console.error("Recognition restart failed:", e);
                            updateStatus('error');
                        }
                    }
                }
            };

            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                if (event.error !== 'no-speech') {
                    updateStatus('error');
                }
            };

            // **[BUG FIX]** onresult handler logic corrected
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscriptFromEvent = '';
                for (let i = 0; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscriptFromEvent += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                finalTranscript = finalTranscriptFromEvent;
                transcriptDiv.innerHTML = `<p>${finalTranscript}<span class="text-gray-500">${interimTranscript}</span></p>`;
            };
        }

        function updateStatus(status, text = '待機中') {
            statusDot.classList.remove('glowing-indicator', 'bg-red-500', 'bg-yellow-500', 'bg-gray-400');
            loadingOverlay.classList.add('hidden');
            loadingOverlay.classList.remove('flex');
            
            switch (status) {
                case 'recording':
                    statusText.textContent = '録音中...';
                    statusDot.classList.add('bg-red-500', 'glowing-indicator');
                    break;
                case 'processing':
                    statusText.textContent = 'AI処理中...';
                    loadingText.textContent = text;
                    statusDot.classList.add('bg-yellow-500');
                    loadingOverlay.classList.remove('hidden');
                    loadingOverlay.classList.add('flex');
                    break;
                case 'idle':
                    statusText.textContent = '待機中';
                    statusDot.classList.add('bg-gray-400');
                    checkTrialLimitAndDisable();
                    break;
                case 'error':
                     statusText.textContent = 'エラー';
                     statusDot.classList.add('bg-red-500');
                     break;
            }
        }

        async function processWithAI(rawText) {
            if (trialCount >= MAX_TRIALS) {
                alert('試用回数を超えました。');
                updateStatus('idle');
                return;
            }
            if (!rawText.trim()) {
                alert('会話が記録されていません。AI処理を中止します。');
                updateStatus('idle');
                return;
            }

            try {
                updateStatus('processing', 'AIが会話を清書中...');
                const proofreadPrompt = `あなたは優秀な医療専門の編集者です。以下の診察の会話の文字起こしに含まれる、誤字、脱字、不自然な言い回しを修正し、医療記録として自然で正確な文章に清書してください。内容を追加したり削除したりせず、元の会話の意tuを忠実に保ってください。\n\n# 元のテキスト:\n${rawText}\n\n# 清書したテキスト:`;
                const cleanedText = await callGemini(proofreadPrompt);
                proofreadTranscriptDiv.textContent = cleanedText;

                updateStatus('processing', 'AIがカルテを作成中...');
                const structuringPrompt = `
あなたは非常に優秀なAI臨床書記です。以下の【清書済みの会話データ】を分析し、情報を抽出・整理してください。
出力は必ず指定されたJSON形式にしてください。

# 清書済みの会話データ
${cleanedText}

# 命令
1. 上記の会話データから、SOAP形式でカルテを作成してください。
   - S (Subjective): 患者の訴え、自覚症状、病歴など。
   - O (Objective): 医師の客観的所見、検査データなど。会話から客観的な事実のみを抽出してください。
   - A (Assessment): 医師の評価や考察、考えられる診断名など。
   - P (Plan): 提案された治療計画、処方、今後の指示など。
2. 上記の会話データに基づき、専門医への紹介状を作成してください。宛名は「専門医先生」とし、丁寧な言葉遣いで作成してください。

# 出力形式 (JSON)
{
  "soap_note": {
    "subjective": "ここにSの内容を記述",
    "objective": "ここにOの内容を記述",
    "assessment": "ここにAの内容を記述",
    "plan": "ここにPの内容を記述"
  },
  "referral_letter": "ここに紹介状の全文を記述"
}
`;
                const structuredDataJson = await callGemini(structuringPrompt, true);
                const structuredData = JSON.parse(structuredDataJson);
                updateUI(structuredData);

                trialCount++;
                localStorage.setItem('aiScribeTrialCount', trialCount);
                updateTrialDisplay();
                

            } catch (error) {
                console.error('Error processing with AI:', error);
                if (error.message.includes('403')) {
                     alert(`AI処理中に権限エラー(403)が発生しました。APIの利用権限がないか、設定に問題がある可能性があります。`);
                } else {
                     alert(`AI処理中にエラーが発生しました: ${error.message}`);
                }
                updateStatus('error');
            } finally {
                updateStatus('idle');
            }
        }
        
        async function callGemini(prompt, isJsonOutput = false) {
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }]
            };

            if (isJsonOutput) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "soap_note": {
                                type: "OBJECT",
                                properties: {
                                    "subjective": { "type": "STRING" },
                                    "objective": { "type": "STRING" },
                                    "assessment": { "type": "STRING" },
                                    "plan": { "type": "STRING" }
                                }
                            },
                           "referral_letter": { "type": "STRING" }
                        }
                    }
                }
            }

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                // **[MODIFIED]** Throw error with status text for better debugging
                throw new Error(`API request failed with status ${response.status} - ${response.statusText}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
                return result.candidates[0].content.parts[0].text;
            } else {
                console.error('Unexpected API response structure:', result);
                throw new Error('AIからの有効な応答がありませんでした。');
            }
        }

        function updateUI(data) {
            if (data.soap_note) {
                outputS.textContent = data.soap_note.subjective || '（情報なし）';
                outputO.textContent = data.soap_note.objective || '（情報なし）';
                outputA.textContent = data.soap_note.assessment || '（情報なし）';
                outputP.textContent = data.soap_note.plan || '（情報なし）';
            }
            if(data.referral_letter) {
                outputReferralLetter.textContent = data.referral_letter || '（情報なし）';
            }
        }
    </script>
</body>
</html>
